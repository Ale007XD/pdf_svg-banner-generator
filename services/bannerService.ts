
import { BannerSettings } from '../types';
import { SAFE_AREA_MARGIN_MM } from '../constants';

// Since we are loading these from a CDN, we declare them to satisfy TypeScript
declare const jspdf: any;
declare const opentype: any;

// A cache for loaded fonts to avoid re-fetching
const fontCache = new Map<string, any>();

async function loadFont(url: string): Promise<any> {
  if (fontCache.has(url)) {
    return fontCache.get(url);
  }
  try {
    // Use fetch to get the font as an ArrayBuffer, which is more reliable than opentype.load()
    const response = await fetch(url);
    if (!response.ok) {
        throw new Error(`Network response was not ok. Status: ${response.status}`);
    }
    const fontBuffer = await response.arrayBuffer();
    const font = opentype.parse(fontBuffer);
    fontCache.set(url, font);
    return font;
  } catch (error) {
    console.error(`Failed to load or parse font from ${url}`, error);
    const fontFileName = url.split('/').pop() || 'unknown font';
    throw new Error(`Font not available: ${fontFileName}`);
  }
}

function calculateTextLayout(font: any, settings: BannerSettings) {
  const { width, height, textLines } = settings;
  
  const safeAreaWidth = width - (SAFE_AREA_MARGIN_MM * 2);
  const safeAreaHeight = height - (SAFE_AREA_MARGIN_MM * 2);
  const filteredTextLines = textLines.filter(line => line.trim() !== '');
  if (filteredTextLines.length === 0) {
    return { paths: [], finalScale: 1 };
  }
  
  const initialFontSize = 1000; // Large arbitrary font size
  let totalHeight = 0;
  let maxWidth = 0;

  filteredTextLines.forEach(line => {
    const path = font.getPath(line, 0, 0, initialFontSize);
    const bbox = path.getBoundingBox();
    totalHeight += bbox.y2 - bbox.y1 + (initialFontSize * 0.2); // 0.2 for line spacing
    maxWidth = Math.max(maxWidth, bbox.x2 - bbox.x1);
  });
  
  totalHeight -= (initialFontSize * 0.2); // Remove last line spacing

  const scaleX = safeAreaWidth / maxWidth;
  const scaleY = safeAreaHeight / totalHeight;
  const finalScale = Math.min(scaleX, scaleY);
  
  const finalFontSize = initialFontSize * finalScale;
  const finalLineHeight = finalFontSize * 1.2;
  const finalTotalHeight = (filteredTextLines.length - 1) * finalLineHeight + finalFontSize;
  
  let currentY = SAFE_AREA_MARGIN_MM + (safeAreaHeight - finalTotalHeight) / 2;

  const paths = filteredTextLines.map((line: string) => {
    const path = font.getPath(line, 0, 0, finalFontSize);
    const bbox = path.getBoundingBox();
    const lineWidth = bbox.x2 - bbox.x1;
    const x = SAFE_AREA_MARGIN_MM + (safeAreaWidth - lineWidth) / 2;
    const y = currentY + finalFontSize * 0.8; // Baseline adjustment
    currentY += finalLineHeight;
    return font.getPath(line, x, y, finalFontSize);
  });

  return { paths, finalScale };
}

export const generatePdf = async (settings: BannerSettings) => {
  const { width, height, backgroundColor, textColor, font } = settings;
  const { jsPDF } = jspdf;
  
  const doc = new jsPDF({
    orientation: width > height ? 'l' : 'p',
    unit: 'mm',
    format: [width, height],
  });

  // Set background color
  const bgCmyk = backgroundColor.cmyk;
  doc.setFillColor(bgCmyk[0] * 255, bgCmyk[1] * 255, bgCmyk[2] * 255, bgCmyk[3] * 255);
  doc.rect(0, 0, width, height, 'F');
  
  // Load font and generate text paths
  const loadedFont = await loadFont(font.url);
  const { paths } = calculateTextLayout(loadedFont, settings);
  
  // Set text color
  const textCmyk = textColor.cmyk;
  doc.setFillColor(textCmyk[0] * 255, textCmyk[1] * 255, textCmyk[2] * 255, textCmyk[3] * 255);

  paths.forEach((path: any) => {
    // jsPDF needs path commands in a specific format
    const pathData = [];
    for (const cmd of path.commands) {
      const type = cmd.type;
      const x = cmd.x;
      const y = cmd.y;
      pathData.push({ op: type, c: [x, y, cmd.x1, cmd.y1, cmd.x2, cmd.y2] });
    }
    doc.path(pathData).fill();
  });
  
  doc.save('banner.pdf');
};

export const generateSvg = async (settings: BannerSettings) => {
  const { width, height, backgroundColor, textColor, font, textLines } = settings;

  const loadedFont = await loadFont(font.url);
  const { paths } = calculateTextLayout(loadedFont, settings);

  const pathElements = paths.map((path: any) => path.toSVG(2)).join('\n');
  const bgCmyk = backgroundColor.cmyk.join(', ');
  const textCmyk = textColor.cmyk.join(', ');

  const svgContent = `
<svg width="${width}mm" height="${height}mm" viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg">
  <!-- Generated by Banner Generator App -->
  <style>
    .bg { fill: ${backgroundColor.hex}; /* CMYK: cmyk(${bgCmyk}) */ }
    .text-path { fill: ${textColor.hex}; /* CMYK: cmyk(${textCmyk}) */ }
  </style>
  <rect class="bg" width="100%" height="100%" />
  <g class="text-path">
    ${pathElements}
  </g>
</svg>
  `.trim();

  const blob = new Blob([svgContent], { type: 'image/svg+xml' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'banner.svg';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
};
